<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>SELISE - WebGL Animation</title>
	<style>
		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}

		html,
		body {
			width: 100%;
			height: 100%;
			background: #000;
			overflow: hidden;
		}

		section {
			width: 100%;
			height: 100%;
			position: relative;
			display: flex;
			align-items: center;
			justify-content: center;
		}

		canvas {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			display: block;
		}

		.back-button {
			position: absolute;
			top: 20px;
			left: 20px;
			background: #fff;
			color: #000;
			padding: 10px 20px;
			text-decoration: none;
			border-radius: 5px;
			font-weight: bold;
			z-index: 10;
		}
	</style>
</head>

<body>
	<a href="index.html" class="back-button">‚Üê Back</a>
	<section>
		<canvas id="v"></canvas>
	</section>

	<script>
		document.addEventListener("DOMContentLoaded", () => {
			const canvas = document.getElementById("v");
			const section = canvas.closest("section");
			let canvasWidth, canvasHeight;
			let gl, program, positionBuffer, indexBuffer;
			let animationFrameId;
			let time = 0;
			let isAnimating = false;
			let gridVertices = [];
			let gridIndices = [];

			function initWebGL() {
				try {
					gl = canvas.getContext("webgl2") || canvas.getContext("webgl");
					if (!gl) {
						console.error("WebGL not supported");
						return false;
					}

					const vertexShader = `
						attribute vec2 position;
						uniform mat4 projection;
						uniform float time;
						uniform float canvasWidth;
						uniform float canvasHeight;

						varying vec3 fragColor;
						varying float circleRadius;

						void main() {
							float posX = position.x;
							float posY = position.y;

							float phase = 0.005 * (0.9 * (canvasWidth - posX) + 1.1 * posY + 500.0 * sin(0.002 * posY)) - time;

							float offsetY = 100.0 * sin(phase)
								+ 50.0 * sin(0.007 * (0.3 * posX + 1.5 * posY) + 0.4 * time)
								+ 30.0 * sin(0.0105 * (1.5 * (canvasWidth - posX) + 0.2 * posY) - 0.7 * time);

							float circleScale = 180.0 * pow(max(0.0, sin(phase)), 2.5);

							float screenX = posX + 10.0 * sin(phase) - circleScale;
							float screenY = posY + offsetY + 0.5 * circleScale;

							gl_Position = projection * vec4(screenX, screenY, 0.0, 1.0);
							gl_PointSize = 3.0;

							float colorValue = 150.0 + 0.58 * offsetY;
							fragColor = vec3(0.0, floor(colorValue / 2.0) / 255.0, floor(colorValue) / 255.0);
							circleRadius = 1.5;
						}
					`;

					const fragmentShader = `
						precision mediump float;
						varying vec3 fragColor;
						varying float circleRadius;

						void main() {
							vec2 center = vec2(0.5, 0.5);
							float dist = distance(gl_PointCoord, center) * 3.0;
							
							float alpha = smoothstep(circleRadius + 0.5, circleRadius - 0.5, dist);
							if (alpha < 0.01) discard;
							
							gl_FragColor = vec4(fragColor, alpha);
						}
					`;

					const vs = gl.createShader(gl.VERTEX_SHADER);
					gl.shaderSource(vs, vertexShader);
					gl.compileShader(vs);

					if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
						console.error("Vertex shader error:", gl.getShaderInfoLog(vs));
						return false;
					}

					const fs = gl.createShader(gl.FRAGMENT_SHADER);
					gl.shaderSource(fs, fragmentShader);
					gl.compileShader(fs);

					if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
						console.error("Fragment shader error:", gl.getShaderInfoLog(fs));
						return false;
					}

					program = gl.createProgram();
					gl.attachShader(program, vs);
					gl.attachShader(program, fs);
					gl.linkProgram(program);

					if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
						console.error("Program link error:", gl.getProgramInfoLog(program));
						return false;
					}

					gl.useProgram(program);

					positionBuffer = gl.createBuffer();
					indexBuffer = gl.createBuffer();

					gl.enable(gl.BLEND);
					gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
					
					gl.clearColor(0, 0, 0, 1);
					return true;
				} catch (error) {
					console.error("WebGL initialization error:", error);
					return false;
				}
			}

			function generateGrid() {
				gridVertices = [];
				gridIndices = [];
				let vertexIndex = 0;

				for (let y = -40; y < canvasHeight + 40; y += 20) {
					for (let x = -40; x < canvasWidth + 40; x += 20) {
						const posX = x + (canvasWidth % 20) / 2;
						const posY = y + (canvasHeight % 20) / 2;

						gridVertices.push(posX, posY);
						gridIndices.push(vertexIndex);
						vertexIndex++;
					}
				}
			}

			const resizeCanvas = () => {
				const size = section
					? { width: section.offsetWidth, height: section.offsetHeight }
					: { width: innerWidth, height: innerHeight };

				canvasWidth = canvas.width = size.width;
				canvasHeight = canvas.height = size.height;

				if (gl) {
					gl.viewport(0, 0, canvasWidth, canvasHeight);

					const left = 0;
					const right = canvasWidth;
					const bottom = canvasHeight;
					const top = 0;

					const proj = [
						2 / (right - left), 0, 0, 0,
						0, 2 / (top - bottom), 0, 0,
						0, 0, -1, 0,
						-(right + left) / (right - left), -(top + bottom) / (top - bottom), 0, 1
					];

					const projLoc = gl.getUniformLocation(program, "projection");
					gl.uniformMatrix4fv(projLoc, false, proj);
				}

				generateGrid();
			};

			window.addEventListener("resize", resizeCanvas);

			if (section && typeof ResizeObserver !== "undefined") {
				new ResizeObserver(() => resizeCanvas()).observe(section);
			}

			resizeCanvas();

			if (!initWebGL()) {
				console.error("Failed to initialize WebGL");
				return;
			}

			function animate() {
				if (!isAnimating) return;

				time += 0.004;

				gl.clear(gl.COLOR_BUFFER_BIT);

				gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(gridVertices), gl.STATIC_DRAW);

				const posLoc = gl.getAttribLocation(program, "position");
				gl.enableVertexAttribArray(posLoc);
				gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

				gl.uniform1f(gl.getUniformLocation(program, "time"), time);
				gl.uniform1f(gl.getUniformLocation(program, "canvasWidth"), canvasWidth);
				gl.uniform1f(gl.getUniformLocation(program, "canvasHeight"), canvasHeight);

				gl.drawArrays(gl.POINTS, 0, gridVertices.length / 2);

				animationFrameId = requestAnimationFrame(animate);
			}

			new IntersectionObserver((entries) => {
				entries.forEach((entry) => {
					if (entry.isIntersecting) {
						if (!isAnimating) {
							isAnimating = true;
							animate();
						}
					} else {
						isAnimating = false;
						if (animationFrameId) {
							cancelAnimationFrame(animationFrameId);
						}
					}
				});
			}, { threshold: 0.1 }).observe(canvas);
		});
	</script>
</body>

</html>